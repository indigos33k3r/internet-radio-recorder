#
# radio-pi lighttpd configuration
# /usr/share/doc/lighttpd-doc/configuration.txt.gz
#

var.baseurl = "/"
var.auth_realm = "Radio Pi"
var.auth_method = "digest"

# for legal reasons mp3 access must be restricted, http://de.wikipedia.org/wiki/Privatkopie#Deutschland :
# see /usr/share/doc/lighttpd/authentication.txt.gz
auth.backend        = "htdigest"
auth.backend.htdigest.userfile  = "/etc/lighttpd/radio-pi.user.htdigest"
#
$HTTP["useragent"] =~ "^AppleCoreMedia/.*\((iP)" {
  # Workaround for Apples Podcast App.
  # 1. does a HEAD request on mp3 with user agent "Podcasts/2.1.2" (auth works if required for HEAD requests)
  # 2. does a GET request on mp3 with user agent "AppleCoreMedia/1.0.0.11D257 (iPhone; U; CPU OS 7_1_2 like Mac OS X; de_de)" (strangely drops credentials => auth fails)
  # so we just allow all such GET requests :-(
  # Really strange is, that PLAYING the mp3 (also agent "AppleCoreMedia/.*\((iPhone)") does properly keep the credentials.
} else $HTTP["useragent"] =~ "^(Podcasts|Instacast)/" {
  # require auth for user agent "Podcasts/" for everything (rss+mp3)
  auth.require = ( baseurl => (
    # see /usr/share/doc/lighttpd/authentication.txt.gz
    "method"  => auth_method,
    "realm"   => auth_realm,
    "require" => "valid-user",
  ), )
} else $HTTP["request-method"] !~ "^(HEAD)$" {
  # Allow all HEAD requests, but require auth for all others on 'enclosures'
  auth.require = ( baseurl + "enclosures" => (
    # see /usr/share/doc/lighttpd/authentication.txt.gz
    "method"  => auth_method,
    "realm"   => auth_realm,
    "require" => "valid-user",
  ), )
}

# enable directory browsing:
dir-listing.activate    = "enable"
dir-listing.show-readme = "enable"

# register lua cgi handler:
static-file.exclude-extensions = ( )
cgi.assign = (
  ".lua" => "/usr/bin/lua",
  ".sh"  => "/bin/dash",
)

# recommended: some convenience redirects (internal):
# http://redmine.lighttpd.net/projects/1/wiki/Docs_ModRewrite
url.rewrite-once = (
    # .cgi to according suffix:
    "^(" + baseurl + "enclosures/app/ad_hoc)\.cgi(.*)$" => "$1.sh$2",
    # legacy: podcast ics + rss
    "^(" + baseurl + "podcasts)/([^\/]*)\.(ics|rss)$" => "$1/$2/broadcasts.$3",
    # consistency: station ics:
    "^(" + baseurl + "stations)/([^\/]*)\.(ics)$" => "$1/$2/broadcasts.$3",
)
url.rewrite-if-not-file = (
  # proper tech-neutral urls, respond with .xml content
  "^(" + baseurl + "stations/[^/]+/\d{4}/\d{2}/\d{2}/\d{4}%20.+)$" => "$1.xml",
)

# required, functional, redirects:
url.redirect = (
    # redirect 'now' to cgi:
    "^" + baseurl + "[^\/]*/([^\/]*)/now$" => "../../app/now.lua?station=$1",
    # redirect podcast episode markers to regular broadcast page: (.xml for legacy compat)
    "^" + baseurl + "podcasts/[^/]+/([^/]+/\d{4}/\d{2}/\d{2}/\d{4}.*?)(\.xml)?$" => baseurl + "stations/$1",
    # redirect unfinished enclosure markers to regular broadcast page:
    "^" + baseurl + "enclosures/([^/]+/\d{4}/\d{2}/\d{2}/\d{4}.*)\.(pending|ripping|failed|purged)$" => baseurl + "stations/$1",

    # convenience
    # redirect time-only, non-title URL
    "^(" + baseurl + ")stations/([^/]+)/(\d{4})/(\d{2})/(\d{2})/(\d{2})(\d{2})(00)?/?$" => "$1app/now.lua?station=$2&t=$3-$4-$5T$6:$7:00",
    "^(" + baseurl + ")stations/([^/]+)/(\d{4})-?(\d{2})-?(\d{2})T?(\d{2}):?(\d{2}):?(\d{2})([+-]\d{2}:?\d{2})" => "$1app/now.lua?station=$2&t=$3-$4-$5T$6:$7:$8$9",

    # legacy:
#    "^" + baseurl + "[^\/]*/([^\/]*)/app/now\.lua$" => "../../../app/now.lua?station=$1",
    # as long as we don't have a proper index.html per day, just use the dir listing:
#    "^(" + baseurl + "stations/[^/]*/\d{4}/\d{2}/\d{2}/)index.html$" => "$1",
)

# proper mimetypes + encodings:
mimetype.assign = (
    ".png"  => "image/png",
    ".xml"  => "text/xml; charset=utf-8",
    ".xslt" => "application/xslt+xml; charset=utf-8",
    ".json" => "application/json; charset=utf-8",
    ".js"   => "text/javascript; charset=utf-8",
    ".html" => "text/html; charset=utf-8",
    ".css"  => "text/css; charset=utf-8",
    ".txt"  => "text/plain; charset=utf-8",
    ".log"  => "text/plain; charset=utf-8",
    ".mp3"  => "audio/mpeg",
    ".rss"  => "application/rss+xml; charset=utf-8",
    ".ics"  => "text/calendar; charset=utf-8",
    ".cfg"  => "text/plain; charset=utf-8",
    ".rb"   => "text/plain; charset=utf-8",
    ".ico"  => "image/vnd.microsoft.icon",
    ".rdf"  => "application/rdf+xml; charset=utf-8",
    ".ttl"  => "text/turtle; charset=utf-8",
    ".rq"   => "application/sparql-query",
)

# bandwidth saving:
compress.filetype = (
    "application/xslt+xml",
    "application/json",
    "text/javascript",
    "text/html",
    "text/css",
    "text/plain",
    "application/rss+xml",
    "application/rdf+xml",
    "text/calendar",
    "text/turtle",
)

# /usr/share/doc/lighttpd-doc/expire.txt
$HTTP["url"] =~ "\.(cfg|js|css|xslt|png|ico|mp3|ttl)$" {
    expire.url = ( "" => "access 1 days" )
}
$HTTP["url"] =~ "modified\.ttl$" {
   expire.url = ( "" => "modification 55 minutes" )
}
# $HTTP["url"] =~ "/modified-.*\.ttl$" {
#     expire.url = ( "" => "modification 1 year" )
# }
$HTTP["url"] !~ "/now\.lua$" {
  # expire all but now.lua - sets header itself
  expire.url = (
    "/app/" => "access 0 years",
    "" => "access 2 minutes",
  )
}

etag.use-inode = "enable"
etag.use-mtime = "enable"
etag.use-size = "enable"
static-file.etags = "enable"
